<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta content="CHAPTER 6. 스트림으로 데이터 수집" name="description"> <meta name="keywords" content="Java,Java8"> <meta name="author" content="Lee Suyoun"> <meta name="baseurl" content=""> <title> Youn's|Java8 in Action : CHAPTER6 </title> <!-- favicon --> <link rel="shortcut icon" href="/static/assets/img/favicon.ico"> <!-- Main CSS --> <link href="/static/assets/app-20171204.min.css" rel="stylesheet"> <link href="/static/css/custom.css" rel="stylesheet"> <!-- Main Scripts --> <script src="/static/assets/app-20171204.min.js"></script> <script src="/static/assets/blog-20171204.min.js"></script> </head> <body id="page-top" class="landing-page"> <div class="search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right: 0px; opacity: 0.95; background-color: #111111; z-index: 9999; display: none;"> <input type="text" class="form-control search-content" id="search-content" style="position: fixed; top: 60px" placeholder="Search Blog"> <div style="position: fixed; top: 16px; right: 16px; z-index: 9999;"> <img src="/static/assets/img/search/cb-close.png" id="close-btn"/> </div> </div> <div style="position: fixed; right: 16px; bottom: 20px; z-index: 9999;"> <img src="/static/assets/img/search/cb-search.png" id="search-btn" title="Double click Ctrl"/> </div> <div class="navbar-wrapper"> <nav class="navbar navbar-default navbar-fixed-top" role="navigation"> <div class="container"> <div class="navbar-header page-scroll"> <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/">Youn's</a> </div> <div id="navbar" class="navbar-collapse collapse"> <ul class="nav navbar-nav navbar-right"> <li><a class="page-scroll" href="blog/"></a></li> <li> <a class="page-scroll" href="/blog/">Blog</a></li> <li> <a class="page-scroll" href="/java/">Java</a></li> <li> <a class="page-scroll" href="/web/">Web</a></li> <li> <a class="page-scroll" href="/database/">Database</a></li> <li> <a class="page-scroll" href="/book/">Book</a></li> <li> <a class="page-scroll" href="/etc/">Etc</a></li> </ul> </div> </div> </nav> </div> <div class="wrapper wrapper-content animated fadeInRight article"> <div class="row"> <div class="col-lg-10 col-lg-offset-1"> <div class="ibox"> <div class="ibox-content"> <div class="pull-right"> <a class="btn btn-white btn-xs" href="/book">Book</a> </div> <div class="text-center article-title"> <span class="text-muted"><i class="fa fa-clock-o"></i> 20 Dec 2017</span> <h1> Java8 in Action : CHAPTER6 </h1> </div> <h2 id="chapter-6-스트림으로-데이터-수집">CHAPTER 6. 스트림으로 데이터 수집</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Collectors 클래스로 컬렉션을 만들고 사용
- 하나의 값으로 데이터 스트림 리듀스
- 특별한 리듀싱 요약 연산
- 데이터 그룹화와 분할
- 자신만의 커스텀 컬렉터 개발
</code></pre></div></div> <ul> <li>자바8의 스트림이란 데이터 집합을 멋지게 처리하는 게으른 반복자</li> <li>스트림의 연산은 filter 또는 map 같은 중간 연산과 count, findFirst, forEach, reduce등의 최종 연산으로 구분</li> <li>중간 연산은 한 스트림을 다른 스트림으로 변환하는 연산으로, 여러 연산을 구분 할수 있음 <ul> <li>스트림 파이프라인을 구성, 스트림의 요소를 소비<sup>consume</sup> 하지 않음</li> </ul> </li> <li> <p>최종연산은 스트림의 요소를 소비해서 최종 결과 도출(예를 들어 스트림의 가장 큰 값 반환)</p> <ul> <li>스트림 파이프라인을 최적화 하면서 계산 과정을 짧게 생략하기도 함</li> </ul> <p><code class="highlighter-rouge">예제 : collect 와 컬렉터로 구현 할수 있는 예제</code></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Currency</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Transaction</span><span class="o">&gt;&gt;</span> <span class="n">transactionByCurrencies</span> <span class="o">=</span>
                                                  <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>    <span class="o">&lt;--</span> <span class="err">그룹화한</span> <span class="err">트랜잭션을</span> <span class="err">저장할</span> <span class="err">맵을</span> <span class="err">생성</span>


<span class="k">for</span><span class="o">(</span><span class="n">Transaction</span> <span class="n">transaction</span> <span class="o">:</span> <span class="n">transactions</span><span class="o">){</span>      <span class="o">&lt;--</span> <span class="err">트랜잭션</span> <span class="err">리스트를</span> <span class="err">반복</span>
  <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">.</span><span class="na">getCurrency</span><span class="o">();</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Transaction</span><span class="o">&gt;</span> <span class="n">transactionForCurrency</span> <span class="o">=</span>
                                        <span class="n">transactionByCurrencies</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">currency</span><span class="o">);</span>
  <span class="k">if</span><span class="o">(</span><span class="n">transactionForCurrency</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>   <span class="o">&lt;--</span> <span class="err">현재</span> <span class="err">통화를</span> <span class="err">그룹화하는</span> <span class="err">맵에</span> <span class="err">항목이</span> <span class="err">없으면</span> <span class="err">항목을</span> <span class="err">만듬</span>
    <span class="n">transactionForCurrency</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">transactionByCurrencies</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">currency</span><span class="o">,</span> <span class="n">transactionForCurrency</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">transactionForCurrency</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">transaction</span><span class="o">);</span>  <span class="o">&lt;--</span> <span class="err">같은</span> <span class="err">통화를</span> <span class="err">가진</span> <span class="err">트랜잭션</span> <span class="err">리스트애</span> <span class="err">현재</span> <span class="err">탐색</span> <span class="err">중인</span> <span class="err">트랜잭션을</span> <span class="err">추가</span>
<span class="o">}</span>
</code></pre></div> </div> <p><code class="highlighter-rouge">Stream에 toList를 사용하는 대신 더 범용적인 컬렉터 파라미터를 collect 메서드에 전달 함으로써 원하는 연산을 간결하게 구현</code></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Currency</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Transaction</span><span class="o">&gt;&gt;</span> <span class="n">transactionByCurrencies</span> <span class="o">=</span>
  <span class="n">transactions</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="nl">Transaction:</span><span class="o">:</span><span class="n">getCurrency</span><span class="o">));</span>
</code></pre></div> </div> </li> </ul> <h3 id="61-컬렉터란-무엇인가">6.1 컬렉터란 무엇인가?</h3> <ul> <li>함수형 프로그래밍에서는 필요한 컬렉터를 쉽게 추가 가능</li> </ul> <blockquote> <p>고급 리듀싱 기능을 수행하는 컬렉터</p> </blockquote> <ul> <li>스트림에 collect를 호출하면 스트림의 요소에(컬렉터로 파라미터화된) 리듀싱 연산이 수행</li> <li>collect에서는 리듀싱 연산을 이용해서 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리</li> <li> <p>가장 많이 사용하는 직곽적인 정적 메서드로 toList를 꼽을 수 있고, toList는 스트림의 모든 요소를 리스트로 수집</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Transaction</span><span class="o">&gt;</span> <span class="n">transactions</span> <span class="o">=</span>
                        <span class="n">transactionStrean</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>미리 정의된 컬렉터</p> </blockquote> <ul> <li>Collectors에서 제공하는 메서드의 기능은 크게 세가지로 구분 <ul> <li>스트림 요소를 하나의 값으로 리듀스하고 요약</li> <li>요소 그룹화</li> <li>요소분할</li> </ul> </li> </ul> <h3 id="62-리듀싱과-요약">6.2 리듀싱과 요약</h3> <ul> <li> <p>컬렉터(Stream.Collect 메서드의 인수)로 스트림의 항목을 컬렉션으로 재구성</p> <p><code class="highlighter-rouge">counting()이라는 팩토리 메서드가 반환하는 컬렉터로 메뉴에서 요리 수를 계산</code></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">howManyDishes</span> <span class="o">=</span> <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">());</span>
</code></pre></div> </div> <p><code class="highlighter-rouge">불필요 한 과정 생략</code></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">howManyDishes</span> <span class="o">=</span> <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">count</span><span class="o">();</span>
</code></pre></div> </div> </li> <li> <p>counting 컬렉터는 다른 컬렉터와 함께 사용할때 위력을 발휘</p> </li> </ul> <blockquote> <p>스트림값에서 최댓값과 최솟값 검색</p> </blockquote> <ul> <li>Collectors.maxBy, Collectors.minBy 두 개의 메서드를 이용해서 스트림의 최댓값과 최솟값을 계산</li> <li> <p>두 컬렉터는 스트림의 요소를 비교하는 데 사용할 Comparator를 인수로 받는다</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;</span> <span class="n">dishCaloriesComparator</span> <span class="o">=</span>
        <span class="n">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getCalories</span><span class="o">);</span>


<span class="n">Optional</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;</span> <span class="n">mostCalorieDish</span> <span class="o">=</span>
        <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">maxBy</span><span class="o">(</span><span class="n">dishCaloriesComparator</span><span class="o">));</span>
</code></pre></div> </div> </li> <li>스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 자주 사용, 이러한 연산을 요약 <sup>summarization</sup> 연산이라고 부름</li> </ul> <blockquote> <p>요약 연산</p> </blockquote> <ul> <li> <p>Collectors 클래스는 Collectors.summingInt라는 특별한 요약 팩토리 메서드를 제공</p> <ul> <li>summingInt는 객체를 int로 매핑하는 함수를 인수로 받음</li> <li>summingInt의 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환</li> <li>summingInt가 collect 메서드로 전달되면 요약 작업 수행</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">totalCalories</span> <span class="o">=</span> <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">summingInt</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getCalories</span><span class="o">));</span>
</code></pre></div> </div> </li> <li> <p>Collectors.averagingInt, averagingLong, averagingDouble 등으로 다양한 형식으로 이루어진 숫자 집합의 평균을 계산</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">avgCalories</span> <span class="o">=</span>
                <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">averagingInt</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getCalories</span><span class="o">));</span>
</code></pre></div> </div> </li> <li> <p>int뿐 아니라 long이나 double에 대응하는 summarizingLong, summarizingDouble 메서드와 관련된 LongSummaryStatistics, DoubleSummaryStatistics 클래스도 있음</p> </li> </ul> <blockquote> <p>문자열 연결</p> </blockquote> <ul> <li> <p>컬렉터에 joining 팩토리 메서드를 이용, 스트림의 각 객체에 toString메서드를 호출 추출한 모든 문자열을 하나의 문자열로 연결해서 반환</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">shortMenu</span> <span class="o">=</span> <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getCalories</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="n">joining</span><span class="o">());</span>
</code></pre></div> </div> </li> <li> <p>joining 메서드는 내부적으로 StringBuilder를 이용해서 문자열을 하나로 만듬</p> </li> <li> <p>toString 메서드를 포함 하고 있다면, map으로 문자를 추출하는 과정을 생략 가능</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">shortMenu</span> <span class="o">=</span> <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">joining</span><span class="o">());</span>
</code></pre></div> </div> </li> <li> <p>구분 문자열을 넣을수 있도록 오버로드된 joining 팩토리 메서드도 있음</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">shortMenu</span> <span class="o">=</span> <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getName</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="n">joining</span><span class="o">(</span><span class="s">","</span><span class="o">));</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>범용 리듀싱 요약 연산</p> </blockquote> <ul> <li>reducing 팩토리 메서드로도 정의 할 수 있음</li> <li> <p>범용 Collectors.reducing으로도 구현 할수 있음</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">totalCalories</span> <span class="o">=</span> <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">reducing</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nl">Dish:</span><span class="o">:</span><span class="n">getCalories</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">));</span>
</code></pre></div> </div> </li> <li> <p>reducing은 세 개의 인수를 받음</p> <ol> <li>리듀싱 연산의 시작값이거나 스트림에 인수가 없을 때는 반환값(숫자 합계에서는 인수가 없을 때 반환값으로 0이 적합)</li> <li>인수는 <code class="highlighter-rouge">요약 연산</code>에서 정수로 변환할 때 사용한 변환 함수</li> <li> <p>같은 종류의 두 항목을 하나의 값으로 더하는 BinaryOperator</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Optional</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;</span> <span class="n">mostCalorieDish</span> <span class="o">=</span>
            <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">reducing</span><span class="o">(</span>
                <span class="o">(</span><span class="n">d1</span><span class="o">,</span> <span class="n">d2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">d1</span><span class="o">.</span><span class="na">getCalories</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">d2</span><span class="o">.</span><span class="na">getCalories</span><span class="o">()</span> <span class="o">?</span> <span class="n">d1</span> <span class="o">:</span> <span class="n">d2</span><span class="o">));</span>
</code></pre></div> </div> </li> </ol> </li> </ul> <h3 id="63-그룹화">6.3 그룹화</h3> <ul> <li>자바8의 함수형을 이용하면 가독성있는 한 줄의 코드로 그룹화를 구현 가능</li> <li> <p>팩토리 메서드 Collectors.groupingBy 이용하여 쉽게 그룹화 가능</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">.</span><span class="na">Type</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;&gt;</span> <span class="n">dishesByType</span> <span class="o">=</span>
                <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getType</span><span class="o">));</span>
</code></pre></div> </div> </li> <li>groupingBy함수를 기준으로 스트림이 그룹화 되므로 이를 <b>분류 함수</b><sup>classification function</sup>라고 함</li> </ul> <blockquote> <p>다수준 그룹화</p> </blockquote> <ul> <li> <p>Collectors.groupingBy는 일반적인 분류 함수와 컬렉터를 인수로 받음</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">.</span><span class="na">Type</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">CaloricLevel</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;&gt;&gt;</span> <span class="nf">groupDishedByTypeAndCaloricLevel</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
            <span class="n">groupingBy</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getType</span><span class="o">,</span>           <span class="o">&lt;--</span> <span class="err">첫</span> <span class="err">번째</span> <span class="err">수준의</span> <span class="err">분류</span> <span class="err">함수</span>
                    <span class="n">groupingBy</span><span class="o">((</span><span class="n">Dish</span> <span class="n">dish</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>     <span class="o">&lt;--</span> <span class="err">두</span> <span class="err">번째</span> <span class="err">수준의</span> <span class="err">분류</span> <span class="err">함수</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">dish</span><span class="o">.</span><span class="na">getCalories</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">400</span><span class="o">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="o">.</span><span class="na">DIET</span><span class="o">;</span>
                        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">dish</span><span class="o">.</span><span class="na">getCalories</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">700</span><span class="o">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="o">.</span><span class="na">NORMAL</span><span class="o">;</span>
                        <span class="k">else</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="o">.</span><span class="na">FAT</span><span class="o">;</span>
                    <span class="o">}</span> <span class="o">)</span>
            <span class="o">)</span>
    <span class="o">);</span>
<span class="o">}</span>
</code></pre></div> </div> </li> <li> <p>보통 groupingBy의 연산을 ‘버킷<sup>bucket</sup>(물건을 담을 수 있는 양동이)’ 개념</p> </li> <li> <p>예제의 첫번째 groupingBy는 각 키의 버킷을 만든다. 그리고 준비된 각각의 버킷을 서브스트림 컬렉터로 채워가기를 반복, n수준 그룹화를 달성</p> </li> </ul> <blockquote> <p>서브그룹으로 데이터 수집</p> </blockquote> <ul> <li>다수준 그룹화 예제에서 첫번째 groupingBy로 넘겨주는 컬렉터의 형식은 제한이 없음</li> <li> <p>팩토리 메서드 Collectors.collectingAndThen으로 컬렉터가 반환한 결과를 다른 형식으로 활용</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">.</span><span class="na">Type</span><span class="o">,</span> <span class="n">Dish</span><span class="o">&gt;</span> <span class="n">mostCaloricByType</span> <span class="o">=</span>
        <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getType</span><span class="o">,</span>      <span class="o">&lt;--</span> <span class="err">분류</span> <span class="err">함수</span>
                                <span class="n">collectingAndThen</span><span class="o">(</span>
                                        <span class="n">maxBy</span><span class="o">(</span><span class="n">comparingInt</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getCalories</span><span class="o">)),</span>     <span class="o">&lt;--</span> <span class="err">감싸인</span> <span class="err">컬렉터</span>
                                <span class="nl">Optional:</span><span class="o">:</span><span class="n">get</span><span class="o">)));</span>       <span class="o">&lt;--</span> <span class="err">변환</span> <span class="err">함수</span>
</code></pre></div> </div> </li> <li>리듀싱 컬렉터는 절대 Optional.empty()를 반환하지 않으므로 안전한 코드</li> </ul> <blockquote> <p>groupingBy와 함께 사용하는 다른 컬렉터 예제</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">.</span><span class="na">Type</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">CaloricLevel</span><span class="o">&gt;&gt;</span> <span class="n">caloricLevelByType</span> <span class="o">=</span>
<span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
      <span class="n">groupingBy</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getType</span><span class="o">,</span> <span class="n">mapping</span><span class="o">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="o">{</span>
              <span class="k">if</span><span class="o">(</span><span class="n">dish</span><span class="o">.</span><span class="na">getCalories</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">400</span><span class="o">)</span> <span class="o">{</span>
                  <span class="k">return</span> <span class="n">CaloricLevel</span><span class="o">.</span><span class="na">DIET</span><span class="o">;</span>
          <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">dish</span><span class="o">.</span><span class="na">getCalories</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">700</span><span class="o">){</span>
              <span class="k">return</span> <span class="n">CaloricLevel</span><span class="o">.</span><span class="na">NORMAL</span><span class="o">;</span>
          <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
              <span class="k">return</span> <span class="n">CaloricLevel</span><span class="o">.</span><span class="na">FAT</span><span class="o">;</span>
          <span class="o">}</span>
<span class="o">},</span>
<span class="n">toSet</span><span class="o">())));</span>
</code></pre></div> </div> </blockquote> <h3 id="64-분할">6.4 분할</h3> <ul> <li>분할은 <b>분할 함수</b><sup>partitioning function</sup>라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능</li> <li>불린을 반환하므로 맵의 키 형식은 <code class="highlighter-rouge">Boolean</code></li> <li> <p>그룹화 맵은 최대(참 아니면 거짓의 값을 갖는) 두 개의 그룹으로 분류</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;&gt;</span> <span class="n">partitionedMenu</span> <span class="o">=</span>
        <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">partitioningBy</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">isVegetarian</span><span class="o">));</span>      <span class="o">&lt;--</span>  <span class="err">분할</span> <span class="err">함수</span>
</code></pre></div> </div> <p><code class="highlighter-rouge">분리된 참값으로 데이터 추출</code></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;</span> <span class="n">vegetarianDishes</span> <span class="o">=</span> <span class="n">partitionedMenu</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>분할의 장점</p> </blockquote> <ul> <li>참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점</li> <li> <p>컬렉터를 두 번째 인수로 전달할 수 있는 오버로드된 버전의 partitioningBy 메서드도 있음</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">.</span><span class="na">Type</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;&gt;&gt;</span> <span class="n">vegetarianDishesByType</span> <span class="o">=</span>
    <span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">partitioningBy</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">isVegetarian</span><span class="o">,</span>        <span class="o">&lt;--</span> <span class="err">분할</span> <span class="err">함수</span>
                  <span class="n">groupingBy</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getType</span><span class="o">)));</span>        <span class="o">&lt;--</span> <span class="err">두</span> <span class="err">번째</span> <span class="err">컬렉터</span>
</code></pre></div> </div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">,</span> <span class="n">Dish</span><span class="o">&gt;</span> <span class="n">mostCaloricPartitionedByVegetarian</span> <span class="o">=</span>
<span class="n">menu</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
      <span class="n">partitioningBy</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">isVegetarian</span><span class="o">,</span>
              <span class="n">collectingAndThen</span><span class="o">(</span>
                      <span class="n">maxBy</span><span class="o">(</span><span class="n">comparingInt</span><span class="o">(</span><span class="nl">Dish:</span><span class="o">:</span><span class="n">getCalories</span><span class="o">)),</span>
                      <span class="nl">Optional:</span><span class="o">:</span><span class="n">get</span><span class="o">)));</span>
</code></pre></div> </div> </li> </ul> <h3 id="65-collector-인터페이스">6.5 Collector 인터페이스</h3> <ul> <li>Collector 인터페이스는 리듀싱 연산(즉, 컬렉터)을 어떻게 구현할지 제공하는 메서드 집합으로 구성</li> <li> <p>Collector 인터페이스의 시그니처와 다섯 개의 메서드 정의</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;{</span>
    <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">supplier</span><span class="o">();</span>
    <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">();</span>
    <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">finisher</span><span class="o">();</span>
    <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">combiner</span><span class="o">();</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="nf">characteristics</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div> </div> <ul> <li>T는 수집될 스트림 항목의 제네릭 형식</li> <li>A는 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식</li> <li> <p>R은 수집 연산 결과 객체의 형식(대게 컬렉션 형식)</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ToListCollector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <blockquote> <p>supplier 메서드 : 새로운 결과 컨테이너 만들기</p> </blockquote> <ul> <li>supplier 메서드는 빈 결과로 이루어진 Supplier를 반환. 즉, supplier는 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수</li> <li> <p>ToListCollector 처럼 누적자를 반환하는 컬렉터에서는 빈 누적자가 비어있는 스트림의 수집 과정의 결과가 될수 없음</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">supplier</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
<span class="o">}</span>
</code></pre></div> </div> <p><code class="highlighter-rouge">생성자 레퍼런스를 전달 방법</code></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">supplier</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>accumulator 메서드 : 결과 컨테이너에 요소 추가하기</p> </blockquote> <ul> <li>accumulator 메서드는 리듀신 연산을 수행하는 함수를 반환</li> <li> <p>ToListCollector에서 accumulator가 반환하는 함수는 이미 탐색한 항목을 포함하는 리스트에 현재 항목을 추가하는 연산 수행</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">(){</span>
    <span class="k">return</span> <span class="nl">List:</span><span class="o">:</span><span class="n">add</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>finisher 메서드 : 최종 변환값을 결과 컨테이너로 적용하기</p> </blockquote> <ul> <li>finisher 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수 반환</li> <li> <p>누적자 객체가 이미 최종 결과일 때는 변환 과정이 필요 없으므로 finisher 메서드는 항등 함수 반환</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">finisher</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>combiner 메서드 : 두 결과 컨테이너 병합</p> </blockquote> <ul> <li>리듀싱 연산에서 사용할 함수를 반환</li> <li> <p>combiner는 스트림의 서로 다른 서브파트를 병렬로 처리 할때 누적자가 이 결과를 어떻게 처리 할지 정의</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">combiner</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">list1</span><span class="o">,</span> <span class="n">list2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">list1</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">list2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">list1</span><span class="o">;</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div> </div> </li> </ul> <blockquote> <p>Characteristics 메서드</p> </blockquote> <ul> <li>컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환</li> <li> <p>Characteristics는 스트림을 병렬로 리듀스 할 것인지 그리고 병렬로 리듀스 한다면 어떤 최적화를 선택해야 할지 힌트 제공</p> <blockquote> <p>UNORDERED</p> </blockquote> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않음
</code></pre></div> </div> <blockquote> <p>CONCURRENT</p> </blockquote> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>다중 스레드에서 accumulator 함수를 동시에 호출 가능, 스트림의 병렬 리듀싱 수행 할 수 있음
데이터 소스가 정렬되어 있지 않은 상황에서만 별렬 리듀싱 수행 할 수 있음
</code></pre></div> </div> <blockquote> <p>IDENTIT_FINISH</p> </blockquote> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>리듀싱 과정의 최종 결과로 누적자 객체를 바로 사용 가능
누적자 A를 결과 R로 안전하게 형변환 할 수 있음
</code></pre></div> </div> </li> </ul> <blockquote> <p>컬렉터 구현을 만들지 않고도 커스텀 수집 수행하기</p> </blockquote> <ul> <li> <p>IDENTITY_FINISH 수집 연산에서는 Collector 인터페이스를 완전히 해로 구현 하지 않고도 같은 결과를 얻을 수 있음</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;</span> <span class="n">dishes</span> <span class="o">=</span> <span class="n">menuStream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span>
                  <span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span>     <span class="o">&lt;--</span> <span class="n">supplier</span>
                  <span class="nl">List:</span><span class="o">:</span><span class="n">add</span><span class="o">,</span>          <span class="o">&lt;--</span> <span class="n">accumulator</span>
                  <span class="nl">List:</span><span class="o">:</span><span class="n">addAll</span><span class="o">);</span>      <span class="o">&lt;--</span> <span class="n">combiner</span>
<span class="o">);</span>
</code></pre></div> </div> </li> </ul> <h3 id="66-커스텀-컬렉터를-구현해서-성능-개선하기">6.6 커스텀 컬렉터를 구현해서 성능 개선하기</h3> <blockquote> <p>소수로만 나누기</p> </blockquote> <ol> <li>Collector 클래스 시그니처 정의</li> <li>리듀싱 연산 구현</li> <li>병렬 실행할 수 있는 컬렉터 만들기</li> <li>finisher 메서드와 컬렉터의 characteristics 메서드</li> </ol> <blockquote> <p>컬렉터 성능 비교</p> </blockquote> <hr> <div class="row"> <div class="col-md-6"> <h5 style="display: inline;">Tags:</h5> <button class="btn btn-white btn-xs" type="button">Java</button> <button class="btn btn-white btn-xs" type="button">Java8</button> </div> <div class="col-md-6"> <div class="small text-right"> <div> <i class="fa fa-comments-o"> </i> <span class="disqus-comment-count" data-disqus-url="http://localhost:4000/book/2017/12/20/Java8-in-Action-cp6.html">0</span> comments </div> </div> </div> </div> <br> <div class="row"> <div class="col-lg-12"> <!-- donate --> <br> <!-- share --> <div class="a2a_kit a2a_kit_size_32 a2a_default_style"> <a class="a2a_dd" href="https://www.addtoany.com/share"></a> <a class="a2a_button_facebook"></a> <a class="a2a_button_twitter"></a> <a class="a2a_button_google_plus"></a> <a class="a2a_button_linkedin"></a> <a class="a2a_button_email"></a> <!--<a class="a2a_button_wechat"></a>--> <!--<a class="a2a_button_sina_weibo"></a>--> <!--<a class="a2a_button_pocket"></a>--> </div> <script> var a2a_config = a2a_config || {}; a2a_config.color_main = "D7E5ED"; a2a_config.color_border = "AECADB"; a2a_config.color_link_text = "333333"; a2a_config.color_link_text_hover = "333333"; </script> <script async src="https://static.addtoany.com/menu/page.js"></script> <br> <!-- comment --> <div id="disqus_thread"></div> <script> /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { var d = document, s = d.createElement('script'); s.src = '//Yons's.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> </div> </div> </div> </div> </div> </div> </div> <!-- Google analytics --> <!-- GrowingIO --> <script id="dsq-count-scr" src="https://Yons's.disqus.com/count.js" async></script> </body> </html>
